# 4.1 У нас є список показань заборгованостей з комунальних послуг наприкінці місяця. Заборгованості можуть бути від'ємними 
# — у нас переплата, чи додатними, якщо необхідно сплатити за рахунками. Напишіть функцію amount_payment, яка приймає 
# на вхід список платежів, підсумовує додатні значення та повертає суму платежу наприкінці місяця.
# -----------------------------------------------------------------------------------------------

def amount_payment(payment):
    payment_all = list(payment)
    sum = 0
    
    for payment in payment_all:
        if payment >= 0:
            sum += payment
        else:
            sum +=0
    return sum 

# 4.2 При аналізі даних часто виникає необхідність позбавитися екстремальних значень, перш ніж почати працювати з даними далі.
# Напишіть функцію prepare_data, яка видаляє з переданого списку найбільше та найменше значення, сортує його в порядку зростання
# і повертає змінений список як результат.
# -----------------------------------------------------------------------------------------------

def prepare_data(data):
    value =list(data)
    value = sorted(value)
    del value[0]
    del value[-1]
    return value
# 4.3 Ми розробляємо кулінарний блог. І в рецептах, при написанні списку інгредієнтів, ми розділяємо їх комами,
# а перед останнім ставимо союз "and", як у прикладі нижче:
# 2 eggs, 1 liter sugar, 1 tsp salt and vinegar
# Напишіть функцію format_ingredients, яка прийматиме на вхід список з інгредієнтів ["2 eggs", "1 liter sugar", "1 tsp salt", "vinegar"]
# та повертатиме рядок зібраний з його елементів в описаний вище спосіб. Ваша функція має вміти обробляти списки будь-якої довжини.
# -----------------------------------------------------------------------------------------------

def format_ingredients(items):
    if len(items) > 2:
        first = items
        list_items = first[-1] 
        list_items1 = first[-2]
        all_list_items = list_items1 + ' and ' + list_items
        first.pop()
        first.pop()
        string_items = ', '.join(first) + ',' + ' ' + all_list_items
        return str(string_items)
    elif len(items) == 2:
        return " and ".join(items)
    else:
        return ''.join(items)
    
# 4.4 Сучасна система оцінок в університеті має такий вигляд:
# Оцінка	Бали	Оцінка ECTS	Пояснення
# 1	0-34	F	Unsatisfactorily
# 2	35-59	FX	Unsatisfactorily
# 3	60-66	E	Enough
# 3	67-74	D	Satisfactorily
# 4	75-89	C	Good
# 5	90-95	В	Very good
# 5	96-100	A	Perfectly
# Реалізуйте дві функції. Перша буде використовуватись у бухгалтерії при розрахунку стипендії, get_grade приймає ключ у вигляді оцінки ECTS,
# і має повертати відповідну п'ятибальну оцінку (перший стовпчик таблиці). Друга get_description теж приймає ключ у вигляді оцінки ECTS,
# але повертатиме пояснення оцінки в текстовому форматі (останній стовпчик таблиці) і буде використана в електронній заліковій книжці студента.
# На відсутній ключ функції повинні повертати значення None .
# -----------------------------------------------------------------------------------------------

def get_grade(key):
    assessment = {'F':1, 'FX':2, 'E':3, 'D':3,	'C':4, 'B':5, 'A':5}  
    return assessment.get(key)

def get_description(key):
    assessment = {'F':'Unsatisfactorily', 'FX':'Unsatisfactorily', 'E':'Enough', 'D':'Satisfactorily',	'C':'Good', 'B':'Very good', 'A':'Perfectly'}  
    return assessment.get(key)

# 4.5 Як ми знаємо, ключ у словнику має бути унікальним, тоді як значення його ні. Реалізуйте функцію lookup_key для пошуку 
# всіх ключів за значенням у словнику. Першим параметром у функцію ми передаємо словник, а другим — значення, що хочемо знайти.
# Таким чином, результат може бути як список ключів, так і порожній список, якщо ми нічого не знайдемо.
# -----------------------------------------------------------------------------------------------

def lookup_key(data, value):
    keys = [key for key, values in data.items() if values == value]
    return keys

# 4.6 У нас є список показників студентів групи – це список з отриманими балами з тестування. Необхідно поділити список на дві частини.
# Напишіть функцію split_list, яка приймає список (цілі числа), знаходить середнє значення бала у списку та ділить його на два списки.
# У перший потрапляють значення менше середнього, включаючи середнє значення, тоді як у другий — строго більше від середнього. 
# Функція повертає кортеж цих двох списків. Для порожнього списку повертаємо два порожні списки.
# -----------------------------------------------------------------------------------------------

def split_list(grade):
    first = []
    second = []
    sum = 0
    if grade == []:
        return (second, first)
    
    for i in grade:
        sum += i
    average =int(sum /len(grade))
    
    for i in grade:
        if i > average:
            first.append(i)      
        elif i <= average:
            second.append(i)
    return (second, first)
    
#  4.7 Є чотирикутна схема польотів дронів з координатами (0, 1, 2, 3). У нас є словник points, ключі якого — кортежі,
# точки польоту між координатами чотирикутника, вигляду (1, 2). Значення словника — це відстані між вказаними точками.
# Приклад:
# points = {(0, 1): 2, (0, 2): 3.8, (0, 3): 2.7, (1, 2): 2.5, (1, 3): 4.1, (2, 3): 3.9}
# Напишіть функцію calculate_distance, яка на вхід приймає список координат чотирикутника зі словника виду [0, 1, 3, 2, 0].
# Функція повинна підрахувати, використовуючи вказаний словник, яку загальну відстань пролетить дрон, рухаючись між точками польоту.
# Примітки:
# коли беремо у словника points значення, у ключі кортежі завжди має бути першою координата з меншим значенням — (2, 3), але не (3, 2);
# для порожнього списку та списку з однією координатою функція calculate_distance має повертати 0.
# -----------------------------------------------------------------------------------------------

points = {
    (0, 1): 2,
    (0, 2): 3.8,
    (0, 3): 2.7,
    (1, 2): 2.5,
    (1, 3): 4.1,
    (2, 3): 3.9,
}


def calculate_distance(coordinates):
    distans = 0
    for point in range(len(coordinates)-1):
        if len(coordinates) <=1:
            return 0
        coordinat = [coordinates[point], coordinates[point+1]]
        print(coordinat)
        distans += points[(min(coordinat), max(coordinat))]
        
    return distans 
 
#  4.8 Потрібно написати функцію реалізації наступного ігрового алгоритму. На вхід функції game подається два аргументи: список,
# що складається зі списків, та початкове значення power - енергія гравця. Внутрішні списки — це списки з числовим значенням енергії,
# які може поглинути гравець, якщо вони менші або дорівнюють його енергії. Після поглинання елементу списку він рухається
# за списком далі та, або поглинає список повністю до кінця, або, якщо знаходить енергію вище за власну,
# залишає його і переходить до наступного списку. Наприкінці обходу всіх списків функція повинна повернути загальну отриману 
# енергію гравця.
# Приклад списку:
# [[1, 1, 5, 10], [10, 2], [1, 1, 1]]
# Для цього списку і початкової енергії рівної 1 гравець поглине з першого списку перші два значення і залишить його,
# зустрівши значення 5, через те, що на цей момент матиме енергію в 3. Другий список пропустить відразу,
# а третій повністю поглине та отримає остаточну енергію в 6.
# -----------------------------------------------------------------------------------------------

def game(terra, power):
    power1 = 0
    all_power  = power
    while True:
        for list_terra in terra:
            for power_terra in list_terra:
                if all_power >= power_terra:
                    power1 += power_terra
                    all_power = power + power1
                else:
                    break
        return 
# 4.9 Всім відомо, що для доступу до кредитної картки банку потрібний пін-код. Класично склалося, що це поєднання чотири цифри.
# Нам необхідно вирішити наступне програмістське завдання. Є підготовлений перелік пін-кодів. Напишіть функцію is_valid_pin_codes,
# яка буде приймати як параметр список цих пін-кодів — рядок з чотирьох цифр і повертати логічне значення — валідний список чи ні.
# Переконайтеся, що серед цих пін-кодів у списку не буде дублікатів, всі вони зберігаються у вигляді рядків, 
# їх довжина дорівнює 4 символам і містять вони тільки цифри.
# Приклад аргументу для функції is_valid_pin_codes:
# ['1101', '9034', '0011']
# Якщо список відповідає всім поставленим умовам, функція повертає логічне значення True. Якщо хоч одну з умов порушено,
# повертається значення — False. Передбачити перевірку на порожній список в аргументі функції та повернути при цьому значення False.
# -----------------------------------------------------------------------------------------------

def is_valid_pin_codes(pin_codes):
     set_code = set (pin_codes)
     if len(pin_codes) != len(set_code):
        return False
     elif pin_codes == []:
        return False
     while True:
        for code in pin_codes:
            
            if code == '':
                return False
            elif code != str(code):
                return False
            elif len(code) != 4:
                return False
            elif code.isdigit() != True:
                return False
                  
        return True
    
# 4.10 Браузер Chrome пропонує нам згенеровані випадкові паролі для сайтів та вебзастосунків.
# Ми потренуємось розв'язувати подібні завдання. Розіб'ємо завдання на три етапи.
# Перший етап — створіть функцію get_random_password, яка буде генерувати випадковий рядок пароля.
# Вимоги:
# у пароля має бути 8 символів.
# для шифрування пароля будемо використовувати наступний набір символів:
# ()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
# Ці символи лежать у межах від 40 до 126 коду в таблиці ASCII включно, і доступ до них можна отримати
# за допомогою функції chr.
# chr(40)  # (
# chr(126)  # ~
# Щоб отримати випадкове ціле значення із заданого діапазону, ми використовуємо стандартний
# модуль Python random та його функцію randint. Вона має виклик виду randint(A, B) і повертає випадкове 
# ціле число N, A ≤ N ≤ B.
# from random import randint
# random_num = randint(40, 126)
# Після виконання коду в змінній random_num буде знаходитися випадкове ціле число від 40 до 126 включно.
# Таким чином функція get_random_password має випадковим чином вибрати із запропонованого діапазону 8 символів
# та повернути згенерований пароль у вигляді рядка.
# -----------------------------------------------------------------------------------------------

from random import randint


def get_random_password():
    result = ''
    count = 0
    while count < 8:
        result += chr(randint(40, 126))
        count += 1
    return result

#  4.11 Другий етап. Необхідно написати функцію is_valid_password, яка перевірятиме отриманий параметр — пароль на надійність.
# Критерії надійного пароля:
# Довжина рядка пароля вісім символів.
# Містить хоча б одну літеру у верхньому регістрі.
# Містить хоча б одну літеру у нижньому регістрі.
# Містить хоча б одну цифру.
# Функція is_valid_password повинна повернути True, якщо переданий параметр пароль відповідає вимогам на надійність.
# Інакше повернути False.
# -----------------------------------------------------------------------------------------------

import re
def is_valid_password(password):
    if len(password)<8:
            return False
    patern_nijn=re.compile('[a-z]')
    patern_verhn=re.compile('[A-Z]') 
    patern_num=re.compile('[0-9]') 
    countBukvVVerhnRegistre=0
    countBukvVNijnemRegistre=0
    countnumbers=0
    for chunk_let in password:
        if  patern_nijn.match(chunk_let):
            countBukvVNijnemRegistre+=1
        elif  patern_verhn.match(chunk_let):
            countBukvVVerhnRegistre+=1
        elif  patern_num.match(chunk_let):
            countnumbers+=1
    if countBukvVNijnemRegistre == 0:
        return False
    if countBukvVVerhnRegistre == 0 :
        return False
    if countnumbers == 0 :
        return False
    return True

# 4.12 І, нарешті, третій, останній етап. Використовуючи рішення із попередніх двох завдань, напишіть функцію get_password,
# яка згенерує нам випадковий надійний пароль та поверне його. Алгоритм простий — ми генеруємо пароль 
# за допомогою функції get_random_password і, якщо він проходить перевірку на надійність функцією is_valid_password,
# повертаємо його, якщо ні — повторюємо ітерацію знову.
# Примітка: Хорошою практикою буде обмежити кількість спроб (наприклад, до 100), щоб не отримати нескінченний цикл.
# -----------------------------------------------------------------------------------------------

from random import randint


def get_random_password():
    result = ""
    count = 0
    while count < 8:
        random_symbol = chr(randint(40, 126))
        result = result + random_symbol
        count = count + 1
    return result


def is_valid_password(password):
    if len(password) != 8:
        return False

    has_upper = False
    has_lower = False
    has_num = False

    for ch in password:
        if ch.isupper():
            has_upper = True
        elif ch.islower():
            has_lower = True
        elif ch.isdigit():
            has_num = True

    return has_upper and has_lower and has_num


def get_password():
    for _ in range(100):
        pas = get_random_password()
        if is_valid_password(pas):
            return pas
    
#  4.13 Працювати з файловою системою в Python рекомендується за допомогою пакета pathlib.
# Основний інструмент в pathlib - Path, об'єкт, який становить собою шлях (адреса у файловій системі).
# Переважно робота з файловою системою ведеться через Path. Path слід сприймати як вказівник на файл чи теку 
# (директорія або каталог). Щоб створити такий Path, достатньо викликати Path як функцію і передати 
# їй аргумент рядок-адресу у файловій системі:
# from pathlib import Path
# p = Path('/home/user/Downloads')  # p Вказує на теку /home/user/Downloads
# У Path є ряд корисних методів та атрибутів:
# p.parent вказує на батьківську теку;
# p.name повертає лише ім'я (рядок) теки або файлу, на який вказує p;
# p.is_dir() повертає True, якщо p вказує на теку, та False, якщо на файл або такий шлях не існує;
# p.is_file() повертає True, якщо p вказує на файл, та False, якщо на теку, або такий шлях не існує;
# p.iterdir() повертає ітератор по всіх файлах та теках усередині теки p;
# from pathlib import Path
# p = Path('/home/user/Downloads')  # p Вказує на теку /home/user/Downloads
# for i in p.iterdir():
#     print(i.name)  # Виведе у циклі імена всіх тек та файлів у /home/user/Downloads
# Слід розуміти, що i у цьому прикладі також будуть об'єктами Path, але вказувати вони будуть на файли та теки всередині
# '/home/user/Downloads'.
# Перш ніж розпочнемо вирішення завдання, хотілося б пояснити різницю між деякими важливими поняттями.
# Шлях до файлу (path) використовується для ідентифікації файлу у системі. Він складається
# з необов'язкової послідовності назв директорій (тек) , в якій є файл, в кінці знаходиться ім'я файлу,
# а також його розширення, якщо воно існує у файлу. Розширення файлу найчастіше говорить нам про тип або формат файлу.
# Шляхи бувають двох типів:
# Абсолютний шлях починається з кореневої директорії та визначає повне дерево каталогів та однозначно визначає місце файлу,
# незалежно від того, де ми знаходимося у файловій системі.
# Відносний шлях — це шлях до файлу щодо іншого файлу або директорії, зазвичай він будується з поточної робочої директорії.
# Модуль pathlib працює з абсолютними та відносними шляхами.
# -----------------------------------------------------------------------------------------------

from pathlib import Path
import sys

def parse_folder(path):
    files = []
    folders = []
    for el in path.iterdir():
        if el.is_dir():
            folders.append(el.name)
        else:
            files.append(el.name)       
            
    return files, folders

#  4.14 Створіть функцію parse_args, яка повертає рядок, складений з аргументів командного рядка, розділених пробілами.
# Наприклад, якщо скрипт був викликаний командою: python run.py first second, 
# то функція parse_args повинна повернути рядок наступного виду 'first second'.
# -----------------------------------------------------------------------------------------------

import sys
def parse_args():
    result = " ".join(sys.argv[1:])
    return result
