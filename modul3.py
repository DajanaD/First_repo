# 3.1 Функція — це окремий блок чи фрагмент програми. Вони служать у програмах декільком цілям. Головна ціль в тому, 
# що код пишеться раз, і після цього ми можемо звертатися до нього з різних місць програми багаторазово. 
# За допомогою функцій легко тестувати різні рішення. Функції приховують деталі реалізації рішення і ми просто працюємо з ними, 
# майже як з операторами.
# Сам блок функції з його реалізацією називається визначенням (defining), а коли ми звертаємося до функції, то говоримо,
# що викликаємо функцію (calling). Після виклику та виконання функції управління повертається в основну програму,
# і виконання програми продовжується одразу після того місця, де відбувся виклик. Ми вже стикалися з функціями input, int, float тощо.
# Визначення функції починається з ключового слова def, після має йти ім'я функції, далі дужка, що відкриває (, дужка, що закриває ) 
# і знак двокрапки :. Тіло функції починається з нового рядка з потрібним відступом. Python вважає, що знайшов кінець тіла функції,
# як тільки відступ у рядку стане такого ж рівня, як в оператора def
# def hello():
#     print('Hello user!')
# Саме визначення функції не змусить код виконатись, необхідно виконати виклик функції
# def hello():
#     print('Hello user!')
# hello()  # Hello user!
# -----------------------------------------------------------------------------------------------

def greeting():
    print('Hello world!')
greeting()

# 3.2 Велику гнучкість функціям надає той факт, що вони можуть приймати аргументи через передачу їм значень у круглих дужках.
# При виклику функції значеннями цих аргументів ініціалізуються змінні параметрів. Параметри прописуються в круглих дужках
# при оголошенні функції. Кількість параметрів визначає кількість аргументів, які передаються під час виклику функції.
# Як приклад, напишемо свою функцію отримання квадратного кореня числа
# def sqrt(a):
#     return a ** 0.5
# print(sqrt(16))  # 4
# Для повернення значення з функції ми використали ключове слово return, після якого йде саме значення. Дійшовши до інструкції з return, 
# функція миттєво припиняє своє виконання, і керування передається інструкції, наступній відразу за викликом функції.
# Значення, що повертається можна присвоїти змінній
# def sqrt(a):
#     return a ** 0.5
# variable = sqrt(16)
# Якщо функція не повертає результату, використання ключового слова return необов'язково. Але можна використати слово return 
# без наступного значення, щоб перервати виконання функції на якомусь моменті. Мало того, return можна використовувати багаторазово
# в будь-якій функції. Вихід із подібної функції відбудеться після досягнення першого return.
# -----------------------------------------------------------------------------------------------

def invite_to_event(username):
    return f"Dear {username}, we have the honour to invite you to our event"

invite_to_event(input ("Enter username: "))

print(invite_to_event) 

# 3.3 Необхідно написати функцію, яка буде обчислювати суму за користування послугами таксі. Сума складається з базового тарифу 40 грн, 
# та 10 грн за кожен кілометр поїздки. Напишіть функцію, яка приймає один параметр — відстань поїздки в кілометрах. Функція має повертати
# підсумкову суму оплати за послуги таксі дійсним числом. Також функція повинна змінювати глобальну змінну — лічильник total_trip після
# кожного виклику та збільшувати її на одиницю.
# -----------------------------------------------------------------------------------------------

base_rate = 40
price_per_km = 10
total_trip = 0


def calculate_trip_price(distance_km):
    sum = base_rate + distance_km * price_per_km
    global  total_trip
    total_trip = total_trip+1
    return sum


calculate_trip_price(5)
print (total_trip)

#  3.4 Необхідно реалізувати функцію розрахунку ціни товару зі знижкою discount_price. Функція приймає ціну price та знижку discount 
# — це дрібне число від 0 до 1. Тут і надалі ми під знижкою розумітимемо коефіцієнт, який визначає розмір від ціни. І на цей розмір 
# ми знижуємо підсумкову вартість товару. Логіку функції необхідно прописати у внутрішній функції apply_discount, використовуючи
# оголошення зміною price як nonlocal.
# -----------------------------------------------------------------------------------------------

def discount_price(price, discount):
    def apply_discount():
        nonlocal price
        price = price - price * discount
        

    apply_discount()
    return price

# 3.5 Напишімо функцію, яка повертає повне ім'я користувача. У базі даних переважно зберігають ім'я користувача first_name, 
# його прізвище last_name та по батькові, або, як заведено в західних країнах, друге ім'я — middle_name. Причому middle_name 
# — це необов'язкова змінна, вона може бути, а може й не передаватися під час виклику функції. Наша функція повертатиме рядок 
# з повним ім'ям 'first_name middle_name last_name', якщо ж змінна middle_name відсутня, то рядок, що повертається повинен 
# бути 'first_name last_name'.
# -----------------------------------------------------------------------------------------------

def get_fullname(first_name, last_name, middle_name = ""):
    if middle_name == "":
        return first_name + " " + last_name
    else:
        return first_name + " " + middle_name + " " + last_name
get_fullname("Ivan", "Ivanov", "Ivanovich")

# 3.6 Створіть функцію format_string для форматування рядка. У функцію ми передаємо рядок string та length довжину нового рядка. 
# Функція повертає новий рядок за наступним алгоритмом:
# Якщо довжина вихідного рядка більша або дорівнює length, ми повертаємо його в тому ж вигляді;
# Якщо вона менша length, ми додаємо попереду рядка пробіли в кількості (length - len(string)) // 2.
# Тести на правильність роботи функції виконуються для наступних наборів аргументів:
# string='aaaaaaaaaaaaaaaaac', length=12
# length=15, string='abaa'
# -----------------------------------------------------------------------------------------------

def format_string(string = "", length = 0):
    if len(string) >= length:
        return string
    else:
        return " " * ((length - len(string)) // 2) + string
    
# 3.7 Наступне завдання буде суто теоретичним, і ми потренуємося працювати з довільною кількістю аргументів.
# Створіть дві функції:
# перша first буде мати першим параметром змінну size, а також вона може приймати будь-яку кількість позиційних аргументів.
# Функція повинна повернути суму size із загальною кількістю переданих до неї позиційних аргументів.
# друга функція second так само матиме першим параметром size і прийматиме довільну кількість ключових аргументів, 
# і також має повернути суму size з кількістю переданих у функцію ключових аргументів.
# Тестові виклики функцій для правильності роботи будуть наступними:
# first(5, "first", "second", "third")
# first(1, "Alex", "Boris")
# second(3, comment_one="first", comment_two="second", comment_third="third")
# second(10, comment_one="Alex", comment_two="Boris")
# -----------------------------------------------------------------------------------------------

def first(size, *sizes):
    
    return size + len(sizes)
first(5, "first", "second", "third")

def second(size, **sizes):
    return size + len(sizes)
    
second(3, comment_one="first", comment_two="second", comment_third="third")    

# 3.8 Онлайн-магазин "У Бобра" надає послугу експрес доставлення своїх товарів за ціною 5¤ за перший товар у замовленні та 2¤ - за всі наступні товари.
# Необхідно реалізувати функцію, яка приймає як перший параметр кількість товарів у замовленні quantity, але також має бути присутнім параметр,
# що передається тільки за ключем discount.
# Параметр discount за замовчуванням має значення 0 - знижки немає. Приймає значення від 0 до 1. Функція cost_delivery повертає загальну суму
# за доставлення товару з урахуванням знижки.
# Треба передбачити, що функція cost_delivery при визові може приймати будь-яку кількість позиційних аргументів.
# Приклад:
# cost_delivery(2, 1, 2, 3)
# При такому виклику quantity дорівнює 2, а параметр discount за умовчанням має значення 0.
# Тестові виклики функції для правильності роботи будуть наступними:
# cost_delivery(2, 1, 2, 3) == 7
# cost_delivery(3, 3) == 9
# cost_delivery(1) == 5
# cost_delivery(2, 1, 2, 3, discount=0.5) == 3.5
# -----------------------------------------------------------------------------------------------

def cost_delivery(quantity, *_, discount=0):
    if discount == 0:
        return 5 + (quantity-1) * 2
    else:
        return (5 + (quantity-1) * 2) * discount

# 3.9 Для функції попереднього завдання створіть рядки документації. Можна використовувати наступний шаблон
    # """Функція повертає суму за доставлення замовлення.

    #  Перший параметр &mdash; кількість товарів в замовленні.
    #  Параметр знижки discount, який передається лише як ключовий, за замовчуванням має значення 0."""
    # -----------------------------------------------------------------------------------------------

def cost_delivery(quantity, *_, discount=0):
    """Функція повертає суму за доставлення замовлення.

    Перший параметр &mdash; кількість товарів в замовленні.
    Параметр знижки discount, який передається лише як ключовий, за замовчуванням має значення 0."""
        
    
    result = (5 + 2 * (quantity - 1)) * (1 - discount)
    return result

# 3.10 Ми проводимо розіграш призів серед перших 50 підписників ютуб-каналу. Ми маємо 7 призів для розіграшу. Може виникнути питання, 
# скільки різних списків переможців ми можемо отримати під час розіграшу? Для цього ми будемо використовувати формулу сполучень без повторень
# Cnk = n! / ((n - k)! · k!)
# де n — це загальна кількість людей (випадків), а k — кількість людей, які отримали призи.
# Напишіть функцію number_of_groups, яка приймає параметри n та k, і за допомогою функції factorial повертає нам скільки різних списків переможців
# ми можемо отримати при розіграші
# Зверніть увагу на те, які великі значення ми отримуємо для факторіала. Рекурсивні висловлювання треба завжди застосовувати з обережністю при обчисленнях,
# щоб не отримати переповнення пам'яті.
# -----------------------------------------------------------------------------------------------

def factorial(n):
    if n == 1:
        return 1
    result = factorial(n - 1) * n
    return result

def number_of_groups(n, k):
   if n == 1:
        return 1
   else:
        result = factorial(n - 1) * n
   if k == 1:
        return 1
   else:
        result1 = factorial(k - 1) * k
   if (n-k) == 1:
        return 1
   else:
        result2 = factorial((n-k) - 1) * (n-k)
    
   result_group = result / (result2 * result1)
   return int(result_group)

# 3.11 Однією з класичних задач на розуміння рекурсії, яку часто задають на співбесідах, особливо початківцям-програмістам — це ряд Фібоначчі.
# Ряд Фібоначчі — це послідовність чисел виду: 0, 1, 1, 2, 3, 5, 8, ... де кожне наступне число послідовності виходить додаванням двох попередніх членів ряду.
# У загальному вигляді для обчислення n-го члена ряду Фібоначчі слід обчислити вираз:
# Fn = Fn-1 + Fn-2.
# Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, доки виклик не сягне членів ряду менше n = 1,
# на якій задана послідовність.
# -----------------------------------------------------------------------------------------------
def fibonacci(n):
    if n in (1, 2):
        return 1
    elif n == 0:
        return 0
    return fibonacci(n - 1) + fibonacci(n - 2)
print(fibonacci(10))